function [opt_results, opt_aggregates] = solve_opt_benefit(pop_growth_rate, params)

if ~exist('pop_growth_rate','var')
    pop_growth_rate = 0.01;
end

if ~exist('params','var')
    params = load(fullfile('params.mat'));
end


% Generating population weights
pop_weights = zeros(1,params.max_age);
pop_weights(1) = 1;
for age = 2:params.max_age
    pop_weights(age) = params.surv_rates(age-1)*pop_weights(age-1)/(1+pop_growth_rate);
end
pop_weights = pop_weights./sum(pop_weights);



% Solving balanced budget over benefits, given population weights

benefits = linspace(0,2,params.num_balanced_budgets);
taxs     = zeros(1,params.num_balanced_budgets);
welfares = zeros(1,params.num_balanced_budgets);

% Setting the fsolve parameters

optim_options = optimoptions('fsolve','MaxIterations',10e10, 'MaxFunctionEvaluations',10e10);

for ib = 1:params.num_balanced_budgets
%     fprintf('%0.0f%% of balanced budget iterations complete.\n', 100*ib/params.num_balanced_budgets)
    % Preallocating vectors
    govt_revs          = zeros( 1, params.num_tax_trials )         ;
    potential_welfares = zeros( 1, params.num_tax_trials )         ;
    tax_grid           = linspace( 0, 0.7, params.num_tax_trials ) ;
    for it = 1:params.num_tax_trials %generate a grid of aggregate benefits and gov't revenue for various tax rates
        [aggregates, profiles] = solve_aggregates_mex(tax_grid(it), pop_weights, benefits(ib),...
                                                    params                                ); %#ok<ASGLU>
        govt_revs         (it) = aggregates.government_revenue;    
        potential_welfares(it) = aggregates.welfare           ;
    end

    f            = @(x) interp1( tax_grid, govt_revs - aggregates.benefits, x,'spline', inf); %interpolates over budget balancing gov't revenue and benefits expenditures
    taxs    (ib) = fsolve(@(x) f(x), (tax_grid(1) + tax_grid(end))/2, optim_options); %finds optimal tax rate over budget balancing rate; uses this to solve for optimized aggregates
    welfares(ib) = interp1(tax_grid,potential_welfares,taxs(ib),'spline', inf);

end

% figure
% plot(benefits,welfares)

g = @(x) -interp1( benefits, welfares,x,'spline',-inf); %interpolates over benefit, welfare grids generated by optimal_value_grid
[opt_benefit, opt_welfare] = fminsearch(@(x) g(x), 0.001); %finds benefit maximizing aggregate welfare
opt_welfare = -1*opt_welfare;
opt_tax     = interp1(benefits, taxs, opt_benefit, 'spline', inf);

%Loading results into structure
opt_results.benefit = opt_benefit;
opt_results.welfare = opt_welfare;
opt_results.tax     = opt_tax    ;

[opt_aggregates, opt_profiles] = solve_aggregates_mex(opt_tax, pop_weights, opt_benefit, params);
opt_aggregates.average_hours = (sum(pop_weights(1:params.retirement_age - 1).*opt_profiles.hours(1:params.retirement_age - 1)))./(sum(pop_weights(1:params.retirement_age - 1)));

end