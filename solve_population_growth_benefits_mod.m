% Danny Aguiar, ECON 479, 4/8/2019
%
% ECON 479 Final: Social Security Benefits and Population Growth Rates
%
% Solves for optimal benefits payments to maximize aggregate welfare for a
% given population growth rate

%Our driver; assigns parameters and generates population weights, then
%calls solve_balanced_budget at each unique growth rate
function solve_population_growth_benefits_mod()

% Assign parameters
params.discount_factor = 1.01                           ;
params.interest_rate   = 1.04                           ;
params.na              = 10                             ;
params.asset_grid      = linspace( 0.01, 20, params.na) ;
params.max_age         = 80                             ;
params.wage            = 1                              ;
params.crra            = 3                              ;
params.cons_share      = 0.25                           ;
params.retirement_age  = 46                             ; 

population_growth_rate_1935 = 0.0069;
population_growth_rate_1955 = 0.0178;
population_growth_rate_1972 = 0.0108;
population_growth_rate_1999 = 0.0115;
population_growth_rate_2019 = 0.0060;

population_growth_rates = [population_growth_rate_1935, population_growth_rate_1955, population_growth_rate_1972, population_growth_rate_1999, population_growth_rate_2019];

params.surv_rates = xlsread('survival_probabilities.xlsx');
pop_weights = zeros(5,params.max_age);
pop_weights(:,1) = 1;

for ip = 1:length(population_growth_rates)
    % Generating population weights

    for age = 2:params.max_age
        pop_weights(ip, age) = params.surv_rates(age-1)*pop_weights(ip,age-1)/(1+population_growth_rates(ip));
    end
    pop_weights(ip,:) = pop_weights(ip,:)./sum(pop_weights(ip,:));
    
end

%preallocating vectors
benefit_grid = linspace(0, 0.1, params.na);
welfare_grid = zeros(5, params.na);
opt_benefits_grid = zeros(1,length(population_growth_rates));

%iterate over all population growth rates
for ip = 1:length(population_growth_rates)
    for ib = 1:length(benefit_grid) %
        fprintf('Solving benefit iteration %i.\n', ib)
        optimal_value_grid = solve_balanced_budget(pop_weights(ip,:), benefit_grid(ib),params); %solve for optimal welfare at each benefit_grid point
        welfare_grid(ip,ib) = optimal_value_grid.welfare;
    end
    figure
    plot(benefit_grid, welfare_grid(ip,:))
    title(['Benefits versus optimal welfare for population growth rate ' num2str(population_growth_rates(ip))])
    xlabel('Benefits Payment')
    ylabel('Optimal Welfare')
    g = @(x) -interp1(benefit_grid, welfare_grid(ip,:),x,'spline',inf); %interpolates over benefit, welfare grids generated by optimal_value_grid
    benefits_optimal = fminsearch(@(x) g(x), (benefit_grid(1) + benefit_grid(end))/2); %finds benefit maximizing aggregate welfare
    fprintf('Population growth rate %i.\n', population_growth_rates(ip))
    fprintf('Optimal benefits for given population growth rate: %i.\n', benefits_optimal)
    opt_benefits_grid(1,ip) = benefits_optimal;
end

end


% Our subfunction that solves for balanced government budget for given
% population weights and benefits payments, then finds the optimal benefit
% that generates the highest welfare value
function optimal_value_grid = solve_balanced_budget(population_weight, benefit, params) 

%preallocating vectors
optimal_value_grid.tax =     zeros(1,params.na)  ;
optimal_value_grid.welfare = zeros(1,params.na)  ;
govt_rev = zeros(1,params.na);


tax_grid = linspace(0, 0.4, params.na);
for it = 1:length(tax_grid) %generate a grid of aggregate benefits and gov't revenue for various tax rates
    aggregates = solve_aggregates(tax_grid(it), population_weight, benefit, params);
    govt_rev(it) = aggregates.government_revenue;    
end

f = @(x) interp1(tax_grid,govt_rev - aggregates.benefits, x,'spline', inf); %interpolates over budget balancing gov't revenue and benefits expenditures
t_opt = fsolve(@(x) f(x), (tax_grid(1) + tax_grid(end))/2); %finds optimal tax rate over budget balancing rate; uses this to solve for optimized aggregates



optimal_value_grid.tax_grid =            tax_grid;
optimal_value_grid.benefits =     aggregates.benefits;
optimal_value_grid.government_revenue = govt_rev;

aggregates_opt = solve_aggregates(t_opt, population_weight, benefit, params); %for given t_opt generates the corresponding optimal aggregates

optimal_value_grid.govt_rev_opt = aggregates_opt.government_revenue;
optimal_value_grid.budget_deficit = aggregates_opt.government_revenue - aggregates.benefits;
optimal_value_grid.welfare =    aggregates_opt.welfare;
optimal_value_grid.tax_opt = t_opt;
end

%Subfunction solving for aggregate savings, hours, gov't revenue, etc.
%based on given tax rate, benefit, and population weight.
function aggregates = solve_aggregates(tax_rate, population_weight, benefit, params)

profiles = solve_lifetime_utility(tax_rate, benefit, params); %calls solve_lifetime utility to generate our corresponding profiles

%distributes profiles over population weights to generate aggregates for
%the given population
aggregates.savings            = sum( population_weight.*profiles.savings(1:end-1) ) ;
aggregates.hours              = sum( population_weight.*profiles.hours            ) ;
aggregates.government_revenue = sum( population_weight.*profiles.tax_bill         ) ;
aggregates.consumption        = sum( population_weight.*profiles.consumption      ) ;
aggregates.benefits           = sum( population_weight.*profiles.benefits         ) ;
aggregates.welfare            = sum( population_weight.*profiles.welfare          ) ;
 
end

% Profile generating function; takes in tax_rate and benefit, solves for
% the optimal savings and labor allocations, then interpolates over these
% values and calls solve_value once again at these optimized rates
function profiles = solve_lifetime_utility(tax_rate, benefit, params)

% Preallocate value and policy functions
value_function = zeros( params.na, params.max_age+1);
savings        = zeros( params.na, params.max_age  );
hours          = zeros( params.na, params.max_age  );
tax_bill       = zeros( params.na, params.max_age  );
consumption    = zeros( params.na, params.max_age  );
benefits_total = zeros( params.na, params.max_age  );

% Solving the agent problem
for age = params.max_age:-1:1
%     fprintf('Solving age %i.\n', age)
    for ia = 1:params.na
        isoptimization = true;
%         initial_guess = [max(params.asset_grid(1),.5*params.asset_grid(ia)),0.9];
        initial_guess = [params.asset_grid(ia),0.9];
        [xopt,fopt] = fminsearch(@(choice_space) solve_value(choice_space, params.asset_grid(ia),...
                         value_function(:,age+1), age, tax_rate, benefit, params, isoptimization),initial_guess, optimset('maxiter',10e5,'maxfunevals',10e5));
        value_function(ia,age) = -fopt;
        savings       (ia,age) =  xopt(1);
        hours         (ia,age) =  xopt(2);
        %----------------------------------------
        isoptimization = false;
        output = solve_value(xopt, params.asset_grid(ia),...
                         value_function(:,age+1), age, tax_rate, benefit, params, isoptimization);
        tax_bill      (ia,age) = output(1);             
        consumption   (ia,age) = output(2);
        benefits_total      (ia,age) = output(3);
    end    
end


% Generating profiles
savings_profile       = zeros(1,params.max_age+1);
hours_profile         = zeros(1,params.max_age  );
tax_bill_profile      = zeros(1,params.max_age  );
consumption_profile   = zeros(1,params.max_age  );
benefits_profile      = zeros(1,params.max_age  );
welfare_profile       = zeros(1,params.max_age  );

savings_profile(1) = params.asset_grid(1);
for age = 1:params.max_age
    savings_profile    (age+1) = interp1( params.asset_grid, savings(:,age), savings_profile        (age) );
    hours_profile      (age  ) = interp1( params.asset_grid, hours  (:,age), savings_profile        (age) );
    welfare_profile    (age  ) = interp1( params.asset_grid, value_function(:, age), savings_profile(age) );
    isoptimization             = false;
    choice_space               = [savings_profile(age+1),hours(age)];
    outputs                    = solve_value(choice_space, savings_profile(age), [], age, tax_rate, benefit, params, isoptimization);
    tax_bill_profile   (age  ) = outputs(1);
    consumption_profile(age  ) = outputs(2);
    benefits_profile    (age ) = outputs(3);
end

profiles.savings     = savings_profile     ;
profiles.hours       = hours_profile       ;
profiles.tax_bill    = tax_bill_profile    ;
profiles.consumption = consumption_profile ;
profiles.benefits    = benefits_profile    ;
profiles.welfare     = welfare_profile     ;

end

% our value and consumption functions: takes in savings choice for next
% period, assets at beginning of period, age, tax rate, benefits, and
% calculates the corresponding utility from these values when optimizing or
% the tax and benefit payments alongside consumption when not optimizing
% during the generation of profiles
function value = solve_value(choice_space, asset, continuation_values, age, tax_rate, benefits, params, isoptimization)

savings_choice = choice_space(1);
hours          = choice_space(2);

% T/F condition for worker or retiree - changes taxes paid, hours worked,
% and benefits received
if age >= params.retirement_age
    retirement_status = 1;
else
    retirement_status = 0;
end

net_income  = (1 - retirement_status)*(params.wage * hours) + (params.interest_rate-1) * asset;
tax_bill    = tax_rate * net_income ;
benefits    = retirement_status * benefits;
consumption = (1 - retirement_status)*(params.wage * hours) + params.interest_rate * asset - savings_choice - tax_bill + retirement_status * benefits  ;

if ~isoptimization %when not optimizing, calculate profile functions for the given individual and parameters
    value = [tax_bill, consumption, benefits];
elseif isoptimization %when optimizing, calculate utility for given individual and parameters
    
    if consumption<=0 || savings_choice<params.asset_grid(1) || savings_choice>params.asset_grid(end) || hours<0 || hours>1
        value = inf;
        return
    end

    utility = (1/(1-params.crra))* ( ( consumption ^ params.cons_share ) * ( (1-hours)^(1-params.cons_share) ) ) ^ (1-params.crra);
    value = utility + params.surv_rates(age)*params.discount_factor*interp1(params.asset_grid,continuation_values,savings_choice);
    value = -1*value;
end

end